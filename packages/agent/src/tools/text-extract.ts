import { JSONSchema } from "../json-schema";
import { EvalContext } from "../sandbox/sandbox";
import { getEnv } from "../env";
import { getTextModelName } from "../model";
import debug from "debug";
import { AuthError, LogicError, NetworkError, InternalError, classifyHttpError, formatUsageForEvent } from "../errors";
import { defineTool, Tool } from "./types";

const debugTextExtract = debug("TextExtract");

const inputSchema: JSONSchema = {
  type: "object",
  properties: {
    text: {
      type: "string",
      minLength: 1,
      description: "Input text to extract data from",
    },
    json_schema: {
      description: "JSON schema object describing the expected output structure",
    },
  },
  required: ["text", "json_schema"],
};

const outputSchema: JSONSchema = {
  type: "object",
  properties: {
    result: {
      description: "Extracted object matching the json_schema",
    },
  },
  required: ["result"],
};

interface Input {
  text: string;
  json_schema: any;
}

interface Output {
  result: any;
}

/**
 * Create the Text.extract tool.
 */
export function makeTextExtractTool(getContext: () => EvalContext): Tool<Input, Output> {
  return defineTool({
    namespace: "Text",
    name: "extract",
    description: `Extract structured data from text according to a JSON schema using AI.
Takes input text and a JSON schema, and returns the extracted data in JSON format.
Uses temperature 0 and light reasoning for reliable parsing.`,
    inputSchema,
    outputSchema,
    execute: async (input) => {
      const { text, json_schema } = input;

      if (!json_schema) throw new LogicError("No json_schema specified", { source: "Text.extract" });

      // OpenRouter's docs say this is required
      json_schema["strict"] = true;

      const env = getEnv();
      if (!env.OPENROUTER_API_KEY?.trim()) {
        throw new AuthError("OpenRouter API key not configured", { source: "Text.extract" });
      }

      const model = getTextModelName();
      const baseURL = env.OPENROUTER_BASE_URL || "https://openrouter.ai/api/v1";

      debugTextExtract(
        `Extracting from text (${text.length} chars) with schema`
      );

      const prompt = `Extract information from the following text and output it in JSON format according to the schema provided.

JSON Schema:
${JSON.stringify(json_schema)}

Text to extract from:
${text}

Output only valid JSON matching the schema, no additional text or markdown formatting.`;

      try {
        const response = await fetch(`${baseURL}/chat/completions`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${env.OPENROUTER_API_KEY}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            model,
            messages: [
              {
                role: "user",
                content: prompt,
              },
            ],
            temperature: 0,
            reasoning_effort: text.length > 10000 ? "medium" : "low",
            response_format: { type: "json_schema", json_schema },
            usage: {
              include: true,
            },
          }),
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw classifyHttpError(
            response.status,
            `OpenRouter API error: ${response.status} - ${errorText}`,
            { source: "Text.extract" }
          );
        }

        const result = await response.json();

        if (!result.choices || result.choices.length === 0) {
          throw new NetworkError("No response generated by the model", { source: "Text.extract" });
        }

        const usage = result.usage || {};
        let content = result.choices[0].message?.content as string;
        if (!content) {
          throw new LogicError("No content found in the response", { source: "Text.extract" });
        }

        debugTextExtract("Extraction completed", content, "usage", usage);

        // Cut markdown just to make sure
        content = content.trim();
        if (content.startsWith("```json"))
          content = content.substring("```json".length);
        if (content.endsWith("```"))
          content = content.substring(0, content.length - "```".length);
        content = content.trim();

        try {
          const data = JSON.parse(content);
          await getContext().createEvent("text_extract", {
            inputLength: text.length,
            output: data,
            ...formatUsageForEvent(usage),
          });

          return { result: data };
        } catch (jsError) {
          debugTextExtract("Failed to parse", content, jsError);
          // Pass the content to the caller for them to figure it out
          throw new LogicError("Error parsing reply: " + content, { source: "Text.extract" });
        }
      } catch (error) {
        // Re-throw if already classified
        if (error instanceof AuthError || error instanceof NetworkError || error instanceof LogicError) {
          throw error;
        }
        throw new InternalError(error instanceof Error ? error.message : String(error), { cause: error instanceof Error ? error : undefined, source: "Text.extract" });
      }
    },
  }) as Tool<Input, Output>;
}

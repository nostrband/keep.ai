import { z } from "zod";
import { tool } from "ai";
import { EvalContext } from "../sandbox/sandbox";
import { getEnv } from "../env";
import { getTextModelName } from "../model";
import debug from "debug";
import { AuthError, LogicError, NetworkError, classifyHttpError, classifyGenericError, isClassifiedError, formatUsageForEvent } from "../errors";

const debugTextSummarize = debug("TextSummarize");

export function makeTextSummarizeTool(getContext: () => EvalContext) {
  return tool({
    description: `Summarize text to a specified maximum length using AI.
Takes input text and optional maximum character count, returns a concise summary.
Uses temperature 0 and no reasoning for straightforward summarization.`,
    inputSchema: z.object({
      text: z.string().min(1).describe("Input text to summarize"),
      prompt: z.string().optional().describe("Additional prompt on how to perform the summarization, preferred output format, etc"),
      max_chars: z
        .number()
        .min(100)
        .max(10000)
        .default(1500)
        .optional()
        .describe(
          "Maximum number of characters in the summary (default: 1500)"
        ),
    }),
    outputSchema: z.object({
      summary: z.string().describe("Summarized text"),
    }),
    execute: async (input) => {
      const { text, prompt: userPrompt = '', max_chars = 1500 } = input;

      const env = getEnv();
      if (!env.OPENROUTER_API_KEY?.trim()) {
        throw new AuthError("OpenRouter API key not configured", { source: "Text.summarize" });
      }

      const model = getTextModelName();
      const baseURL = env.OPENROUTER_BASE_URL || "https://openrouter.ai/api/v1";

      debugTextSummarize(
        `Summarizing text (${text.length} chars) to max ${max_chars} chars`
      );

      const prompt = `Summarize the following text in approximately ${max_chars} characters or less. Provide a clear, concise summary that captures the key points.
${userPrompt ? userPrompt : ''}

If the input text is malformed, empty, or you cannot perform the summarization for any reason, provide brief reasoning and then output <ERROR>Short-error-text</ERROR> where Short-error-text explains the issue.

Text to summarize:
${text}`;

      try {
        const response = await fetch(`${baseURL}/chat/completions`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${env.OPENROUTER_API_KEY}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            model,
            messages: [
              {
                role: "user",
                content: prompt,
              },
            ],
            temperature: 0,
            max_tokens: Math.ceil(max_chars / 2), // Rough estimate: ~2 chars per token
            reasoning_effort: text.length > 10000 ? "medium" : "low",
            usage: {
              include: true,
            },
          }),
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw classifyHttpError(
            response.status,
            `OpenRouter API error: ${response.status} - ${errorText}`,
            { source: "Text.summarize" }
          );
        }

        const result = await response.json();

        if (!result.choices || result.choices.length === 0) {
          throw new NetworkError("No response generated by the model", { source: "Text.summarize" });
        }

        const usage = result.usage || {};
        const content = result.choices[0].message?.content?.trim();
        if (!content) {
          throw new LogicError("No content found in the response", { source: "Text.summarize" });
        }

        // Check for error pattern
        const errorMatch = content.match(/<ERROR>(.*?)<\/ERROR>/s);
        if (errorMatch) {
          const errorMessage = errorMatch[1].trim();
          throw new LogicError(errorMessage || "LLM reported an error", { source: "Text.summarize" });
        }

        debugTextSummarize(
          "Summarization completed",
          {
            inputLength: text.length,
            summaryLength: content.length,
          },
          "usage",
          usage
        );

        await getContext().createEvent("text_summarize", {
          inputLength: text.length,
          summaryLength: content.length,
          maxChars: max_chars,
          ...formatUsageForEvent(usage),
        });

        return { summary: content };
      } catch (error) {
        // Re-throw if already classified
        if (isClassifiedError(error)) {
          throw error;
        }
        throw classifyGenericError(error instanceof Error ? error : new Error(String(error)), "Text.summarize");
      }
    },
  });
}

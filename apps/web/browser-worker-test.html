<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Worker Sync Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .test-results {
            margin-top: 20px;
        }
        .test-case {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
            border-left: 4px solid #ccc;
        }
        .test-case.pass {
            background-color: #d4edda;
            border-left-color: #28a745;
        }
        .test-case.fail {
            background-color: #f8d7da;
            border-left-color: #dc3545;
        }
        .test-case.running {
            background-color: #fff3cd;
            border-left-color: #ffc107;
        }
        .controls {
            margin-bottom: 20px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .log {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        .summary {
            font-weight: bold;
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
        }
        .summary.pass {
            background-color: #d4edda;
            color: #155724;
        }
        .summary.fail {
            background-color: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Browser Worker Synchronization Test</h1>
        <p>This test verifies that the CRSqlite worker synchronization works correctly in a browser environment.</p>
        
        <div class="controls">
            <button id="runTest" onclick="runTests()">Run Tests</button>
            <button id="clearLog" onclick="clearLog()">Clear Log</button>
        </div>

        <div class="test-results" id="testResults">
            <!-- Test results will be populated here -->
        </div>

        <div class="container">
            <h3>Test Log</h3>
            <div class="log" id="testLog"></div>
        </div>
    </div>

    <script type="module">
        // Import required modules
        import { createDBBrowser } from '@app/browser';
        import {
            CRSqliteWorkerBase,
            CRSqliteWorkerClientBase
        } from '@app/worker';
        
        // Simple test assertion framework
        class TestRunner {
            constructor() {
                this.tests = [];
                this.currentTest = null;
                this.results = [];
            }

            describe(name, fn) {
                this.currentSuite = name;
                fn();
            }

            it(name, fn) {
                this.tests.push({
                    suite: this.currentSuite,
                    name,
                    fn
                });
            }

            expect(actual) {
                return {
                    toBe: (expected) => {
                        if (actual !== expected) {
                            throw new Error(`Expected ${actual} to be ${expected}`);
                        }
                    },
                    toHaveLength: (expected) => {
                        if (actual.length !== expected) {
                            throw new Error(`Expected length ${actual.length} to be ${expected}`);
                        }
                    },
                    toBeGreaterThan: (expected) => {
                        if (actual <= expected) {
                            throw new Error(`Expected ${actual} to be greater than ${expected}`);
                        }
                    },
                    toBeDefined: () => {
                        if (actual === undefined) {
                            throw new Error(`Expected value to be defined`);
                        }
                    }
                };
            }

            async run() {
                this.results = [];
                const resultsContainer = document.getElementById('testResults');
                resultsContainer.innerHTML = '';

                for (const test of this.tests) {
                    const testElement = document.createElement('div');
                    testElement.className = 'test-case running';
                    testElement.innerHTML = `<strong>${test.suite}: ${test.name}</strong> - Running...`;
                    resultsContainer.appendChild(testElement);

                    try {
                        this.log(`Running: ${test.suite}: ${test.name}`);
                        await test.fn();
                        testElement.className = 'test-case pass';
                        testElement.innerHTML = `<strong>${test.suite}: ${test.name}</strong> - ✅ PASS`;
                        this.results.push({ ...test, status: 'pass' });
                        this.log(`✅ PASS: ${test.name}`);
                    } catch (error) {
                        testElement.className = 'test-case fail';
                        testElement.innerHTML = `<strong>${test.suite}: ${test.name}</strong> - ❌ FAIL<br><small>${error.message}</small>`;
                        this.results.push({ ...test, status: 'fail', error: error.message });
                        this.log(`❌ FAIL: ${test.name} - ${error.message}`);
                    }
                }

                this.showSummary();
            }

            showSummary() {
                const passed = this.results.filter(r => r.status === 'pass').length;
                const failed = this.results.filter(r => r.status === 'fail').length;
                const total = this.results.length;

                const summaryElement = document.createElement('div');
                summaryElement.className = `summary ${failed === 0 ? 'pass' : 'fail'}`;
                summaryElement.innerHTML = `
                    <strong>Test Summary:</strong> ${passed}/${total} tests passed
                    ${failed > 0 ? `<br>${failed} tests failed` : ''}
                `;
                
                document.getElementById('testResults').appendChild(summaryElement);
                this.log(`\nTest Summary: ${passed}/${total} tests passed`);
            }

            log(message) {
                const logElement = document.getElementById('testLog');
                const timestamp = new Date().toLocaleTimeString();
                logElement.textContent += `[${timestamp}] ${message}\n`;
                logElement.scrollTop = logElement.scrollHeight;
                console.log(message);
            }
        }

        // Extended worker class for testing
        class TestWorker extends CRSqliteWorkerBase {
            constructor(db) {
                super(db, async (msg) => this.broadcastChanges(msg));
                this.messages = [];
                this.clientPeer = null;
            }

            setClient(client) {
                this.clientPeer = client;
            }

            // Override to capture and forward broadcast messages
            async broadcastChanges(message) {
                this.messages.push(message);
                // Forward to client peer
                if (this.clientPeer) {
                    await this.clientPeer.processChanges(message);
                }
            }
        }

        // Extended client class for testing
        class TestClient extends CRSqliteWorkerClientBase {
            constructor(db) {
                super(db, async (msg) => this.broadcastMessage(msg));
                this.sentMessages = [];
                this.broadcastMessages = [];
                this.receivedResponses = [];
                this.workerPeer = null;
                this.workerPort = null;
            }

            setWorker(worker, port) {
                this.workerPeer = worker;
                this.workerPort = port;
            }

            // Override to capture and forward messages to worker
            postMessage(message) {
                this.sentMessages.push(message);
                // Forward to worker peer
                if (this.workerPeer && this.workerPort) {
                    this.workerPeer.processClientMessage(message, this.workerPort);
                }
            }

            // Override to capture and forward broadcast messages
            async broadcastMessage(message) {
                this.broadcastMessages.push(message);
                // Forward to worker peer
                if (this.workerPeer) {
                    await this.workerPeer.processChanges(message);
                }
            }

            // Override to capture received responses
            async processWorkerMessage(response) {
                this.receivedResponses.push(response);
                return super.processWorkerMessage(response);
            }
        }

        // Mock WorkerResponsePort that forwards responses back to client
        class MockWorkerResponsePort {
            constructor(client) {
                this.responses = [];
                this.client = client || null;
            }

            setClient(client) {
                this.client = client;
            }

            postMessage(response) {
                this.responses.push(response);
                // Forward response back to client
                if (this.client) {
                    this.client.processWorkerMessage(response);
                }
            }
        }

        // Global test runner instance
        const runner = new TestRunner();

        // Test setup functions
        async function setupTestTables(db, prefix) {
            await db.exec(`
                CREATE TABLE IF NOT EXISTS notes (
                    id TEXT PRIMARY KEY NOT NULL,
                    title TEXT NOT NULL DEFAULT '',
                    content TEXT,
                    created_at INTEGER DEFAULT (strftime('%s', 'now')),
                    updated_at INTEGER DEFAULT (strftime('%s', 'now'))
                )
            `);

            await db.exec(`
                CREATE TABLE IF NOT EXISTS tasks (
                    id TEXT PRIMARY KEY NOT NULL,
                    title TEXT NOT NULL DEFAULT '',
                    completed INTEGER DEFAULT 0,
                    priority INTEGER DEFAULT 1,
                    created_at INTEGER DEFAULT (strftime('%s', 'now'))
                )
            `);

            await db.exec("SELECT crsql_as_crr('notes')");
            await db.exec("SELECT crsql_as_crr('tasks')");

            runner.log(`${prefix} tables created and registered with CRSqlite`);
        }

        async function getTableData(db, table) {
            const result = await db.execO(`SELECT * FROM ${table} ORDER BY id`);
            return result || [];
        }

        // Define the tests
        runner.describe("CRSqlite Worker and Client Synchronization", () => {
            runner.it("should synchronize data between client and worker", async () => {
                let workerDb, clientDb, worker, client, workerPort;

                try {
                    // Create in-memory databases using browser implementation
                    runner.log("Creating browser databases");
                    workerDb = await createDBBrowser(":memory:");
                    clientDb = await createDBBrowser(":memory:");
                    runner.log("Browser databases created");

                    // Create test tables on both sides
                    await setupTestTables(workerDb, "worker");
                    await setupTestTables(clientDb, "client");

                    // Create test instances
                    worker = new TestWorker(workerDb);
                    client = new TestClient(clientDb);
                    workerPort = new MockWorkerResponsePort();

                    // Connect peers
                    workerPort.setClient(client);
                    worker.setClient(client);
                    client.setWorker(worker, workerPort);

                    // Start worker and client
                    await worker.start();
                    await client.start();

                    // Initial sync - client requests sync from worker
                    await client.requestSync();
                    runner.log("Initial sync requested");

                    // Wait for sync to complete
                    await new Promise(resolve => setTimeout(resolve, 100));

                    // Insert data on client side
                    await clientDb.exec(
                        "INSERT INTO notes (id, title, content) VALUES (?, ?, ?)",
                        ["note1", "Client Note 1", "Content from client"]
                    );

                    await clientDb.exec(
                        "INSERT INTO tasks (id, title, completed, priority) VALUES (?, ?, ?, ?)",
                        ["task1", "Client Task 1", 0, 1]
                    );

                    // Trigger sync for client changes
                    await client.checkChanges();
                    await new Promise(resolve => setTimeout(resolve, 100));

                    // Insert data on worker side
                    await workerDb.exec(
                        "INSERT INTO notes (id, title, content) VALUES (?, ?, ?)",
                        ["note2", "Worker Note 2", "Content from worker"]
                    );

                    await workerDb.exec(
                        "INSERT INTO tasks (id, title, completed, priority) VALUES (?, ?, ?, ?)",
                        ["task2", "Worker Task 2", 1, 2]
                    );

                    // Sync worker changes to client
                    await worker.checkChanges();
                    await new Promise(resolve => setTimeout(resolve, 100));

                    // Update data on both sides
                    await clientDb.exec("UPDATE notes SET content = ? WHERE id = ?", [
                        "Updated content from client",
                        "note2"
                    ]);

                    await workerDb.exec("UPDATE tasks SET completed = ? WHERE id = ?", [
                        1,
                        "task1"
                    ]);

                    // Trigger syncs
                    await client.checkChanges();
                    await new Promise(resolve => setTimeout(resolve, 100));

                    await worker.checkChanges();
                    await new Promise(resolve => setTimeout(resolve, 100));

                    // Delete data
                    await clientDb.exec("DELETE FROM notes WHERE id = ?", ["note1"]);
                    await workerDb.exec("DELETE FROM tasks WHERE id = ?", ["task2"]);

                    // Final sync
                    await client.checkChanges();
                    await new Promise(resolve => setTimeout(resolve, 100));

                    await worker.checkChanges();
                    await new Promise(resolve => setTimeout(resolve, 100));

                    // Verify final state - both databases should be identical
                    const clientNotes = await getTableData(clientDb, "notes");
                    const workerNotes = await getTableData(workerDb, "notes");
                    const clientTasks = await getTableData(clientDb, "tasks");
                    const workerTasks = await getTableData(workerDb, "tasks");

                    runner.log(`Client notes: ${JSON.stringify(clientNotes)}`);
                    runner.log(`Worker notes: ${JSON.stringify(workerNotes)}`);
                    runner.log(`Client tasks: ${JSON.stringify(clientTasks)}`);
                    runner.log(`Worker tasks: ${JSON.stringify(workerTasks)}`);

                    // Verify data consistency
                    runner.expect(clientNotes).toHaveLength(1);
                    runner.expect(workerNotes).toHaveLength(1);
                    runner.expect(clientNotes[0].id).toBe("note2");
                    runner.expect(workerNotes[0].id).toBe("note2");
                    runner.expect(clientNotes[0].content).toBe("Updated content from client");
                    runner.expect(workerNotes[0].content).toBe("Updated content from client");

                    runner.expect(clientTasks).toHaveLength(1);
                    runner.expect(workerTasks).toHaveLength(1);
                    runner.expect(clientTasks[0].id).toBe("task1");
                    runner.expect(workerTasks[0].id).toBe("task1");
                    runner.expect(clientTasks[0].completed).toBe(1);
                    runner.expect(workerTasks[0].completed).toBe(1);

                    // Verify that changes were properly exchanged
                    runner.expect(client.sentMessages.length).toBeGreaterThan(0);
                    runner.expect(worker.messages.length).toBeGreaterThan(0);
                    runner.expect(workerPort.responses.length).toBeGreaterThan(0);

                    runner.log("Test completed successfully");

                } finally {
                    // Cleanup
                    if (worker) worker.stop();
                    if (client) client.stop();
                    if (workerDb) await workerDb.close();
                    if (clientDb) await clientDb.close();
                }
            });
        });

        // Global functions for HTML buttons
        window.runTests = async function() {
            const button = document.getElementById('runTest');
            button.disabled = true;
            button.textContent = 'Running...';
            
            try {
                await runner.run();
            } finally {
                button.disabled = false;
                button.textContent = 'Run Tests';
            }
        };

        window.clearLog = function() {
            document.getElementById('testLog').textContent = '';
            document.getElementById('testResults').innerHTML = '';
        };

        // Auto-run tests on page load
        window.addEventListener('load', () => {
            runner.log('Browser Worker Sync Test loaded. Click "Run Tests" to start.');
        });
    </script>
</body>
</html>
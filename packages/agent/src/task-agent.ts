import type { LanguageModel, ModelMessage, UIMessage } from "ai";
import {
  convertToModelMessages,
  generateId,
  readUIMessageStream,
  streamText,
} from "ai";
import debug from "debug";
import { getMessageText } from "./utils";
import { AssistantUIMessage } from "packages/proto/dist";

export type StepReason = "start" | "step" | "input" | "timer";

export type TaskState = {
  goal?: string;
  notes?: string;
  plan?: string;
  asks?: string[];
  resumeAt?: string;
};

export type StepInput = {
  step: number;
  reason: StepReason;
  inbox: string[];
  now: string; // ISO
  task?: TaskState;
  result?: {
    ok: boolean;
    result?: any;
    error?: string;
  };
};

export type StepKind = "done" | "step" | "wait";

export type StepOutput = { steps: number; reasoning?: string } & (
  | { kind: "done"; reply: string; patch?: TaskState }
  | { kind: "step"; code: string; patch?: TaskState }
  | { kind: "wait"; patch: TaskState }
);

export type TaskType = "router" | "worker" | "replier";

export type Task = {
  type: TaskType;
  systemPrompt?: string;
  temperature?: number;
  maxTokens?: number;
  budget?: { stepTokens?: number; taskTokens?: number };
  state?: TaskState;
  onTrace?: (e: { phase: string; data?: any }) => void;
};

export interface Env {
  tools?: string[];
  notes?: string[];
  tasks?: string[];
}

export class TaskAgent {
  public readonly history: AssistantUIMessage[] = [];

  private state?: TaskState;
  private debug = debug("TaskAgent");

  constructor(private args: { model: LanguageModel; task: Task; env?: Env }) {
    if (args.task.state) this.state = { ...args.task.state };
  }

  async runStep(input: StepInput): Promise<StepOutput> {
    const { model } = this.args;
    const { temperature = 0.2, maxTokens = 1000 } = this.args.task;

    const system = this.buildSystem();
    const user = this.buildUser(input);
    // this.debug("system_prompt:", system);
    // this.debug("user_message:", user);

    this.args.task.onTrace?.({ phase: "step-prompt", data: { system, user } });

    // New user message
    this.history.push({
      id: generateId(),
      role: "user",
      parts: [{ type: "text", text: user }],
      metadata: {
        createdAt: new Date().toISOString(),
      },
    });
    const messages: ModelMessage[] = [
      { role: "system", content: system },
      ...convertToModelMessages(this.history),
    ];
    console.log("llm request messages", JSON.stringify(messages, null, 2));

    const result = streamText({
      model,
      temperature,
      toolChoice: "none",
      maxOutputTokens: maxTokens,
      messages,
    });

    let newMessage: UIMessage | undefined;
    for await (const uiMessage of readUIMessageStream({
      stream: result.toUIMessageStream(),
    })) {
      newMessage = uiMessage;
    }
    if (!newMessage) throw new Error("Failed to get streamed reply");

    this.debug("llm response message:", newMessage);
    // this.debug(
    //   "llm full response",
    //   JSON.stringify((await result.response).messages)
    // );

    // Put to history
    this.history.push({
      ...newMessage,
      id: generateId(),
      metadata: {
        createdAt: new Date().toISOString(),
      },
    });

    const text = getMessageText(newMessage);
    this.debug("LLM response text", text);
    this.args.task.onTrace?.({ phase: "llm-output", data: { text } });

    const output = this.parseMSP(input.step + 1, text);
    this.debug("LLM response output", output);
    this.args.task.onTrace?.({ phase: "step-output", data: output });

    return output;
  }

  private buildSystem(): string {
    let { systemPrompt } = this.args.task;

    let tools: string[] = [];
    if (this.args.env?.tools?.length)
      tools = [
        "Available REPL tools (JS functions) are listed below and are available through 'globalThis'. ",
        "Check docs(<tool.Name.String>) to get tool descriptions.",
        "Tools:",
        ...this.args.env.tools.map((t) => `- ${t}`),
      ];
    // let tasks: string[] = [];

    if (!systemPrompt) {
      switch (this.args.task.type) {
        case "replier":
        case "router": {
          systemPrompt = `
You are a sub-agent of a personal AI assistant. You can use REPL JS sandbox
to access memories and tools, to do calculations and to store intermediate data between steps.

You will process tasks generated by user or the host system. 
Task input and output will be in Markdown Sections Protocol (MSP).

You will receive task input including these sections:
- STEP - specifies current step info (why and when you're running)
- TASK_INBOX - list of new messages supplied by user
- PREV_STEP_RESULT - results of code execution of previous step
- PREV_STEP_ERROR - error of code execution of previous step

You must respond with task output using MSP sections below.
Do NOT include any prose outside these sections.

===STEP_KIND===
required, one of: step | done
===STEP_CODE===
\`\`\`js
// only when STEP_KIND=step; raw JS here, no escaping
\`\`\`
===TASK_REPLY===
only when STEP_KIND=done; reply for user
===STEP_REASONING===
optional, explain your decision for audit traces
===END===

Output guidelines:
- Prefer minimal, high-quality code cells.
- Do not add any extra sections or commentary to your output.

JS code guidelines:
- you MUST 'return' the value you need to receive (must be convertible to JSON)
- no 'fetch', no console.log/error, no direct network or disk
- do not wrap your code in '(async () => {...})()' - that's already done for you
- all tools are async and must be await-ed
`;
          break;
        }
        default: {
          throw new Error("Not implemented yet");
        }
      }
    }

    return `
${systemPrompt?.trim() || ""}

${tools.join("\n")}
`.trim();
  }

  private buildUser(input: StepInput): string {
    if (input.reason === "step" && !input.result)
      throw new Error("No step result");

    const state = input.task || this.state;

    let job = "";
    switch (this.args.task.type) {
      case "router":
        break;
      case "replier":
        if (input.step === 0)
          job = `
Some background tasks have submitted their reply drafts for user into your TASK_INBOX. Your job is to check the user message history
and prepare a context-aware reply for user, maintaining a natural flow of the conversation. You might need to deduplicate the
drafts, or even suppress some of them if the draft is no longer relevant/answered according to recent message history. Leave TASK_REPLY empty 
in case all drafts should be suppressed, but explain your reasoning in STEP_REASONING.
        `;
        break;
    }

    let prefix = "";
    if (input.reason === "start")
      prefix =
        "Read through user messages in TASK_INBOX and act accordingly. Use memory.* tools to understand the context better.";
    else if (input.inbox.length > 0)
      prefix =
        "Check results of previous step and read through new messages in TASK_INBOX and act accordingly. Use memory.* tools to understand the context better.";

    let body = [
      job,
      "",
      prefix,
      "",
      "===STEP===",
      `Reason: ${input.reason}`,
      `Now: ${input.now}`,
    ].join("\n");

    if (state && this.args.task.type === "worker") {
      body += [
        "",
        "===TASK_GOAL===",
        state.goal,
        "===TASK_PLAN===",
        state.plan,
        "===TASK_ASKS===",
        state.asks?.map((a) => `- ${a}`).join("\n") || "",
        "===TASK_NOTES===",
        state.notes,
      ].join("\n");
    }

    body += [
      "",
      "===TASK_INBOX===",
      input.inbox.map((s, i) => `- ${s}`).join("\n"),
    ].join("\n");

    if (input.result) {
      body += [
        "",
        `===${input.result.ok ? "PREV_STEP_RESULT" : "PREV_STEP_ERROR"}===`,
        safeStringify(input.result.result || input.result.error, 10000),
      ].join("\n");
    }

    return body;
  }

  private parseMSP(steps: number, text: string): StepOutput {
    const kind = getSection(text, "STEP_KIND")?.trim();
    switch (this.args.task.type) {
      case "replier":
      case "router": {
        if (kind !== "done" && kind !== "step")
          throw new Error("STEP_KIND must be 'step' or 'done'");
        break;
      }
      default: {
        throw new Error("Not supported yet");
      }
    }

    const reasoning = getSection(text, "STEP_REASONING")?.trim();

    switch (kind) {
      case "done": {
        const reply = getSection(text, "TASK_REPLY");
        if (!reply)
          throw new Error("TASK_REPLY is required for STEP_KIND='done'");
        return {
          steps,
          kind,
          reasoning,
          reply,
        };
      }
      case "step": {
        let code = getSection(text, "STEP_CODE");
        if (code) code = extractCodeBlock(code);
        if (!code)
          throw new Error("STEP_CODE is required for STEP_KIND='step'");
        return {
          steps,
          kind,
          reasoning,
          code: extractCodeBlock(code),
        };
      }
    }

    // const replyRaw = getSection(text, "TASK_REPLY", this.isReplyRequired(kind));
    // const asksRaw = getSection(text, "TASK_ASKS", this.isAsksRequired(kind));
    // const resumeAtRaw = getSection(
    //   text,
    //   "TASK_RESUME_AT",
    //   this.isResumeRequired(kind)
    // )?.trim();
    // const goalRaw = getSection(text, "TASK_GOAL");
    // const notesRaw = getSection(text, "TASK_NOTES");
    // const planRaw = getSection(text, "TASK_PLAN");

    // const code = codeRaw ? extractCodeBlock(codeRaw) : undefined;

    // let asks: string[] | undefined = undefined;
    // if (asksRaw) {
    //   asks = asksRaw
    //     .split("\n")
    //     .map((l) => l.trim())
    //     .filter((l) => l.startsWith("- "))
    //     .map((l) => l.slice(2).trim())
    //     .filter(Boolean);
    // }

    // return {
    //   kind,
    //   reply: replyRaw,
    //   patch: {
    //     asks,
    //     goal: goalRaw,
    //     notes: notesRaw,
    //     plan: planRaw,
    //     resumeAt: resumeAtRaw,
    //   },
    //   code,
    // };
  }
}

function escapeRegExp(s: string) {
  // Escape user-provided section names for use in a RegExp
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

export function getSection(text: string, name: string): string | undefined {
  const esc = escapeRegExp(name);
  // Match: ===NAME=== [optional whitespace] (capture everything lazily)
  // until the next line that starts with ===SOMETHING=== or end of string.
  const re = new RegExp(
    `===${esc}===\\s*([\\s\\S]*?)(?=(?:\\r?\\n)===.+?===|$)`
  );
  const m = text.match(re);
  return m ? m[1].trimEnd() : undefined;
}

function extractCodeBlock(s: string): string {
  const m =
    s.match(/```(?:js|javascript)?\s*([\s\S]*?)```/i) ??
    s.match(/```([\s\S]*?)```/);
  if (m) return m[1].trim();
  // Fallback: if no fences, treat whole section as code
  return s.trim();
}

// -------- small utils --------

function safeStringify(obj: any, cap: number): string {
  try {
    if (obj === undefined) return "undefined";
    const s = JSON.stringify(obj);
    return s.length > cap ? s.slice(0, cap - 1) + "â€¦" : s;
  } catch {
    return "[unserializable result]";
  }
}

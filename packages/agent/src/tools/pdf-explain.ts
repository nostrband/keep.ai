import { z } from "zod";
import { tool } from "ai";
import { FileStore } from "@app/db";
import { EvalContext } from "../sandbox/sandbox";
import { getEnv } from "../env";
import { fileUtils } from "@app/node";
import debug from "debug";

const debugPdfExplain = debug("PdfExplain");

export function makePdfExplainTool(
  fileStore: FileStore,
  userPath: string | undefined,
  getContext: () => EvalContext
) {
  return tool({
    description: `Analyze and explain PDF documents using AI.
Takes a PDF file path/ID and a question about the document, uploads the PDF to an AI model and returns the textual explanation.
`,
    inputSchema: z.object({
      file_path: z
        .string()
        .min(1)
        .describe("File path of the PDF to analyze"),
      prompt: z
        .string()
        .min(1)
        .max(2000)
        .describe("Question or prompt about the PDF - what you want to know or understand about the document"),
    }),
    outputSchema: z.object({
      explanation: z.string().describe("AI-generated textual explanation or analysis of the PDF"),
      file_info: z.object({
        id: z.string().describe("File ID"),
        name: z.string().describe("Original filename"),
        size: z.number().describe("File size in bytes"),
      }).describe("Information about the analyzed PDF file"),
    }),
    execute: async (input) => {
      const { file_path: file, prompt } = input;

      if (!userPath) {
        throw new Error("User path not configured");
      }

      // Get environment variables
      const env = getEnv();
      if (!env.OPENROUTER_API_KEY?.trim()) {
        throw new Error("OpenRouter API key not configured");
      }

      const pdfModel = env.PDF_MODEL || "openai/gpt-oss-120b";

      // Extract filename without extension to use as ID
      const filename = fileUtils.basename(file, fileUtils.extname(file));
      
      // Get file record from database
      const fileRecord = await fileStore.getFile(filename);
      if (!fileRecord) {
        throw new Error(`File not found with ID: ${filename}`);
      }

      // Validate that it's a PDF format
      const supportedTypes = ['application/pdf'];
      if (!supportedTypes.includes(fileRecord.media_type)) {
        throw new Error(`Unsupported file format: ${fileRecord.media_type}. Supported formats: ${supportedTypes.join(', ')}`);
      }

      // Construct full path to actual file
      const fullPath = fileUtils.join(userPath, "files", fileRecord.path);
      
      // Check if file exists
      if (!fileUtils.existsSync(fullPath)) {
        throw new Error(`PDF file not found on disk: ${fullPath}`);
      }

      try {
        debugPdfExplain(`Analyzing PDF ${fileRecord.name}, prompt: ${prompt}`);

        // Read the PDF file and convert to base64
        const fd = fileUtils.openSync(fullPath, 'r');
        let pdfBuffer: Uint8Array;
        try {
          const stats = fileUtils.fstatSync(fd);
          const fileSize = stats.size;
          
          // Check file size limit (10MB)
          const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
          if (fileSize > MAX_FILE_SIZE) {
            throw new Error(`PDF file too large: ${Math.round(fileSize / 1024 / 1024 * 100) / 100}MB. Maximum allowed: 10MB`);
          }
          
          pdfBuffer = fileUtils.allocBuffer(fileSize);
          fileUtils.readSync(fd, pdfBuffer, 0, fileSize, 0);
        } finally {
          fileUtils.closeSync(fd);
        }
        
        const base64PDF = `data:application/pdf;base64,${fileUtils.bufferToBase64(pdfBuffer)}`;

        // Call OpenRouter API for PDF analysis
        const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${env.OPENROUTER_API_KEY}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: pdfModel,
            messages: [
              {
                role: 'user',
                content: [
                  {
                    type: 'text',
                    text: prompt,
                  },
                  {
                    type: 'file',
                    file: {
                      filename: fileRecord.name,
                      file_data: base64PDF,
                    },
                  },
                ],
              },
            ],
          }),
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`OpenRouter API error: ${response.status} - ${errorText}`);
        }

        const result = await response.json();

        if (!result.choices || result.choices.length === 0) {
          throw new Error("No response generated by the model");
        }

        const message = result.choices[0].message;
        if (!message.content) {
          throw new Error("No content found in the response");
        }

        // Extract text content from the response
        let explanation = "";
        if (typeof message.content === 'string') {
          explanation = message.content;
        } else if (Array.isArray(message.content)) {
          // Concatenate text parts
          explanation = message.content
            .filter((part: any) => part.type === 'text')
            .map((part: any) => part.text)
            .join('');
        } else {
          throw new Error("Unexpected content format in response");
        }

        debugPdfExplain("PDF analysis completed", { explanation: explanation.substring(0, 100) + '...' });

        // Create event for tracking
        await getContext().createEvent("pdf_explain", {
          file: fileRecord.name,
          prompt,
          explanation: explanation.substring(0, 200) + (explanation.length > 200 ? '...' : '')
        });

        return {
          explanation,
          file_info: {
            id: fileRecord.id,
            name: fileRecord.name,
            size: fileRecord.size,
          },
        };

      } catch (error) {
        throw new Error(`PDF analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      }
    },
  });
}
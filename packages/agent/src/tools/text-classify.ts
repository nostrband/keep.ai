import { JSONSchema } from "../json-schema";
import { EvalContext } from "../sandbox/sandbox";
import { getEnv } from "../env";
import { getTextModelName } from "../model";
import debug from "debug";
import { AuthError, LogicError, NetworkError, InternalError, classifyHttpError, isClassifiedError, formatUsageForEvent } from "../errors";
import { defineReadOnlyTool, Tool } from "./types";

const debugTextClassify = debug("TextClassify");

const inputSchema: JSONSchema = {
  type: "object",
  properties: {
    text: {
      type: "string",
      minLength: 1,
      description: "Input text to analyze for classification",
    },
    classes: {
      type: "array",
      items: {
        type: "object",
        properties: {
          id: { type: "string", description: "Class identifier" },
          description: {
            type: "string",
            description: "Description of when this class should be selected",
          },
        },
        required: ["id", "description"],
      },
      minItems: 1,
      description: "List of possible classes to choose from",
    },
  },
  required: ["text", "classes"],
};

const outputSchema: JSONSchema = {
  type: "object",
  properties: {
    class_id: { type: "string", description: "ID of the selected class" },
  },
  required: ["class_id"],
};

interface ClassOption {
  id: string;
  description: string;
}

interface Input {
  text: string;
  classes: ClassOption[];
}

interface Output {
  class_id: string;
}

/**
 * Create the Text.classify tool.
 * This is a read-only tool - can be used outside Items.withItem().
 */
export function makeTextClassifyTool(getContext: () => EvalContext): Tool<Input, Output> {
  return defineReadOnlyTool({
    namespace: "Text",
    name: "classify",
    description: `Classify text into one of several classes based on its content using AI.
Takes input text and a list of possible classes (each with id and description), and returns the most appropriate class id.
Uses temperature 0 and light reasoning for consistent classification decisions.

ℹ️ Not a mutation - can be used outside Items.withItem().`,
    inputSchema,
    outputSchema,
    execute: async (input) => {
      const { text, classes } = input;

      const env = getEnv();
      if (!env.OPENROUTER_API_KEY?.trim()) {
        throw new AuthError("OpenRouter API key not configured", { source: "Text.classify" });
      }

      const model = getTextModelName();
      const baseURL = env.OPENROUTER_BASE_URL || "https://openrouter.ai/api/v1";

      debugTextClassify(
        `Classifying text (${text.length} chars) with ${classes.length} options`
      );

      const classesList = classes
        .map((c) => `- ${c.id}: ${c.description}`)
        .join("\n");

      const prompt = `You are a text classifier. Based on the input text, select the most appropriate class from the options below.

Available classes:
${classesList}

Input text:
${text}

If the input is malformed, doesn't make sense, or you cannot determine an appropriate class, provide brief reasoning and then output <ERROR>Short-error-text</ERROR> where Short-error-text explains the issue.

Otherwise, return ONLY the class id, nothing else.`;

      try {
        const response = await fetch(`${baseURL}/chat/completions`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${env.OPENROUTER_API_KEY}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            model,
            messages: [
              {
                role: "user",
                content: prompt,
              },
            ],
            temperature: 0,
            // not 'none', otherwise it won't classify properly
            reasoning_effort: text.length > 10000 ? "medium" : "low",
            usage: {
              include: true,
            },
          }),
        });

        if (!response.ok) {
          const errorText = await response.text();
          throw classifyHttpError(
            response.status,
            `OpenRouter API error: ${response.status} - ${errorText}`,
            { source: "Text.classify" }
          );
        }

        const result = await response.json();

        if (!result.choices || result.choices.length === 0) {
          throw new NetworkError("No response generated by the model", { source: "Text.classify" });
        }

        const usage = result.usage || {};
        const content = result.choices[0].message?.content?.trim();
        if (!content) {
          throw new LogicError("No content found in the response", { source: "Text.classify" });
        }

        // Check for error pattern
        const errorMatch = content.match(/<ERROR>(.*?)<\/ERROR>/s);
        if (errorMatch) {
          const errorMessage = errorMatch[1].trim();
          throw new LogicError(errorMessage || "LLM reported an error", { source: "Text.classify" });
        }

        debugTextClassify(
          "Classification completed",
          { selectedClass: content },
          "usage",
          usage
        );

        await getContext().createEvent("text_classify", {
          textLength: text.length,
          classCount: classes.length,
          selectedClass: content,
          ...formatUsageForEvent(usage),
        });

        return { class_id: content };
      } catch (error) {
        // Re-throw if already classified
        if (isClassifiedError(error)) {
          throw error;
        }
        throw new InternalError(error instanceof Error ? error.message : String(error), { cause: error instanceof Error ? error : undefined, source: "Text.classify" });
      }
    },
  }) as Tool<Input, Output>;
}

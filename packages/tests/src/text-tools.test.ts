import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import {
  makeTextGenerateTool,
  makeTextSummarizeTool,
  makeTextClassifyTool,
  makeTextExtractTool,
  setEnv,
  type EvalContext,
} from "@app/agent";

function createMockContext(): EvalContext {
  return {
    taskThreadId: "test-thread",
    step: 0,
    type: "workflow",
    taskId: "test-task",
    cost: 0,
    createEvent: vi.fn().mockResolvedValue(undefined),
    onLog: vi.fn().mockResolvedValue(undefined),
  };
}

/** Helper to create a mock fetch Response for OpenRouter chat completions */
function mockChatResponse(content: string, usage = {}) {
  return {
    ok: true,
    status: 200,
    json: async () => ({
      choices: [{ message: { content } }],
      usage,
    }),
    text: async () => "",
  };
}

function mockErrorResponse(status: number, body: string) {
  return {
    ok: false,
    status,
    text: async () => body,
    json: async () => ({}),
  };
}

describe("Text Tools", () => {
  let mockContext: EvalContext;
  let originalFetch: typeof globalThis.fetch;

  beforeEach(() => {
    mockContext = createMockContext();
    originalFetch = globalThis.fetch;
    setEnv({
      OPENROUTER_API_KEY: "test-key-123",
      OPENROUTER_BASE_URL: "https://mock-openrouter.test/v1",
    });
  });

  afterEach(() => {
    globalThis.fetch = originalFetch;
  });

  describe("Text.generate", () => {
    it("should generate text successfully", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(
        mockChatResponse("This is generated text.", { prompt_tokens: 10, completion_tokens: 20 })
      );

      const tool = makeTextGenerateTool(() => mockContext);
      const result = await tool.execute({ prompt: "Write a haiku" });

      expect(result).toEqual({ text: "This is generated text." });
      expect(mockContext.createEvent).toHaveBeenCalledWith("text_generate", expect.objectContaining({
        promptLength: 13,
        generatedLength: 23,
        temperature: 0.3,
        maxChars: 1500,
      }));
    });

    it("should pass temperature and max_chars to API", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(mockChatResponse("Result"));

      const tool = makeTextGenerateTool(() => mockContext);
      await tool.execute({ prompt: "test", temperature: 0.8, max_chars: 5000 });

      const fetchCall = (globalThis.fetch as any).mock.calls[0];
      const body = JSON.parse(fetchCall[1].body);
      expect(body.temperature).toBe(0.8);
      expect(body.max_tokens).toBe(Math.ceil(5000 / 2));
    });

    it("should throw AuthError when API key is missing", async () => {
      setEnv({ OPENROUTER_API_KEY: "" });

      const tool = makeTextGenerateTool(() => mockContext);

      await expect(tool.execute({ prompt: "test" })).rejects.toThrow(
        "OpenRouter API key not configured"
      );
    });

    it("should throw LogicError when LLM returns ERROR tag", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(
        mockChatResponse("I cannot do that. <ERROR>Inappropriate content</ERROR>")
      );

      const tool = makeTextGenerateTool(() => mockContext);

      await expect(tool.execute({ prompt: "bad prompt" })).rejects.toThrow(
        "Inappropriate content"
      );
    });

    it("should classify HTTP errors from API", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(
        mockErrorResponse(429, "Rate limited")
      );

      const tool = makeTextGenerateTool(() => mockContext);

      await expect(tool.execute({ prompt: "test" })).rejects.toThrow();
    });

    it("should throw NetworkError when no choices returned", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: async () => ({ choices: [] }),
        text: async () => "",
      });

      const tool = makeTextGenerateTool(() => mockContext);

      await expect(tool.execute({ prompt: "test" })).rejects.toThrow(
        "No response generated by the model"
      );
    });

    it("should throw LogicError when response content is empty", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: async () => ({ choices: [{ message: { content: "" } }] }),
        text: async () => "",
      });

      const tool = makeTextGenerateTool(() => mockContext);

      await expect(tool.execute({ prompt: "test" })).rejects.toThrow(
        "No content found in the response"
      );
    });

    it("should use default temperature and max_chars", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(mockChatResponse("ok"));

      const tool = makeTextGenerateTool(() => mockContext);
      await tool.execute({ prompt: "test" });

      const body = JSON.parse((globalThis.fetch as any).mock.calls[0][1].body);
      expect(body.temperature).toBe(0.3);
      expect(body.max_tokens).toBe(Math.ceil(1500 / 2));
    });

    it("should be a read-only tool", () => {
      const tool = makeTextGenerateTool(() => mockContext);
      expect(tool.isReadOnly?.({} as any)).toBe(true);
    });
  });

  describe("Text.summarize", () => {
    it("should summarize text successfully", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(
        mockChatResponse("This is a summary.", { prompt_tokens: 100, completion_tokens: 10 })
      );

      const tool = makeTextSummarizeTool(() => mockContext);
      const result = await tool.execute({ text: "A very long text..." });

      expect(result).toEqual({ summary: "This is a summary." });
      expect(mockContext.createEvent).toHaveBeenCalledWith("text_summarize", expect.objectContaining({
        inputLength: 19,
        summaryLength: 18,
        maxChars: 1500,
      }));
    });

    it("should include user prompt in summarization request", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(mockChatResponse("Summary"));

      const tool = makeTextSummarizeTool(() => mockContext);
      await tool.execute({ text: "Some text", prompt: "Focus on key points" });

      const body = JSON.parse((globalThis.fetch as any).mock.calls[0][1].body);
      expect(body.messages[0].content).toContain("Focus on key points");
    });

    it("should use low reasoning for short text", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(mockChatResponse("Summary"));

      const tool = makeTextSummarizeTool(() => mockContext);
      await tool.execute({ text: "Short text" });

      const body = JSON.parse((globalThis.fetch as any).mock.calls[0][1].body);
      expect(body.reasoning_effort).toBe("low");
    });

    it("should use medium reasoning for long text", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(mockChatResponse("Summary"));

      const tool = makeTextSummarizeTool(() => mockContext);
      await tool.execute({ text: "x".repeat(10001) });

      const body = JSON.parse((globalThis.fetch as any).mock.calls[0][1].body);
      expect(body.reasoning_effort).toBe("medium");
    });

    it("should throw AuthError when API key is missing", async () => {
      setEnv({ OPENROUTER_API_KEY: "  " });

      const tool = makeTextSummarizeTool(() => mockContext);

      await expect(tool.execute({ text: "test" })).rejects.toThrow(
        "OpenRouter API key not configured"
      );
    });

    it("should throw LogicError when LLM returns ERROR tag", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(
        mockChatResponse("<ERROR>Cannot summarize empty text</ERROR>")
      );

      const tool = makeTextSummarizeTool(() => mockContext);

      await expect(tool.execute({ text: "bad" })).rejects.toThrow(
        "Cannot summarize empty text"
      );
    });

    it("should be a read-only tool", () => {
      const tool = makeTextSummarizeTool(() => mockContext);
      expect(tool.isReadOnly?.({} as any)).toBe(true);
    });
  });

  describe("Text.classify", () => {
    it("should classify text successfully", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(
        mockChatResponse("urgent", { prompt_tokens: 50, completion_tokens: 5 })
      );

      const classes = [
        { id: "urgent", description: "Requires immediate attention" },
        { id: "normal", description: "Can wait" },
        { id: "low", description: "Not important" },
      ];

      const tool = makeTextClassifyTool(() => mockContext);
      const result = await tool.execute({ text: "Server is down!", classes });

      expect(result).toEqual({ class_id: "urgent" });
      expect(mockContext.createEvent).toHaveBeenCalledWith("text_classify", expect.objectContaining({
        textLength: 15,
        classCount: 3,
        selectedClass: "urgent",
      }));
    });

    it("should include class descriptions in the prompt", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(mockChatResponse("a"));

      const classes = [
        { id: "a", description: "Category A" },
        { id: "b", description: "Category B" },
      ];

      const tool = makeTextClassifyTool(() => mockContext);
      await tool.execute({ text: "some text", classes });

      const body = JSON.parse((globalThis.fetch as any).mock.calls[0][1].body);
      expect(body.messages[0].content).toContain("- a: Category A");
      expect(body.messages[0].content).toContain("- b: Category B");
    });

    it("should throw LogicError when LLM returns ERROR tag", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(
        mockChatResponse("<ERROR>Cannot determine class</ERROR>")
      );

      const tool = makeTextClassifyTool(() => mockContext);

      await expect(
        tool.execute({ text: "test", classes: [{ id: "a", description: "A" }] })
      ).rejects.toThrow("Cannot determine class");
    });

    it("should throw AuthError when API key is missing", async () => {
      setEnv({ OPENROUTER_API_KEY: undefined });

      const tool = makeTextClassifyTool(() => mockContext);

      await expect(
        tool.execute({ text: "test", classes: [{ id: "a", description: "A" }] })
      ).rejects.toThrow("OpenRouter API key not configured");
    });

    it("should use temperature 0 for consistent classification", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(mockChatResponse("a"));

      const tool = makeTextClassifyTool(() => mockContext);
      await tool.execute({ text: "test", classes: [{ id: "a", description: "A" }] });

      const body = JSON.parse((globalThis.fetch as any).mock.calls[0][1].body);
      expect(body.temperature).toBe(0);
    });

    it("should be a read-only tool", () => {
      const tool = makeTextClassifyTool(() => mockContext);
      expect(tool.isReadOnly?.({} as any)).toBe(true);
    });
  });

  describe("Text.extract", () => {
    it("should extract structured data successfully", async () => {
      const extractedData = { name: "John", age: 30 };
      globalThis.fetch = vi.fn().mockResolvedValue(
        mockChatResponse(JSON.stringify(extractedData), { prompt_tokens: 50, completion_tokens: 10 })
      );

      const schema = {
        type: "object",
        properties: {
          name: { type: "string" },
          age: { type: "number" },
        },
      };

      const tool = makeTextExtractTool(() => mockContext);
      const result = await tool.execute({ text: "John is 30 years old", json_schema: schema });

      expect(result).toEqual({ result: extractedData });
      expect(mockContext.createEvent).toHaveBeenCalledWith("text_extract", expect.objectContaining({
        inputLength: 20,
        output: extractedData,
      }));
    });

    it("should strip markdown code fences from response", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(
        mockChatResponse('```json\n{"key": "value"}\n```')
      );

      const tool = makeTextExtractTool(() => mockContext);
      const result = await tool.execute({
        text: "test",
        json_schema: { type: "object" },
      });

      expect(result).toEqual({ result: { key: "value" } });
    });

    it("should throw LogicError when JSON parsing fails", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(
        mockChatResponse("not valid json at all")
      );

      const tool = makeTextExtractTool(() => mockContext);

      await expect(
        tool.execute({ text: "test", json_schema: { type: "object" } })
      ).rejects.toThrow("Error parsing reply:");
    });

    it("should throw LogicError when json_schema is not provided", async () => {
      const tool = makeTextExtractTool(() => mockContext);

      await expect(
        tool.execute({ text: "test", json_schema: null })
      ).rejects.toThrow("No json_schema specified");
    });

    it("should set strict: true on the json_schema", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(
        mockChatResponse('{"a": 1}')
      );

      const schema = { type: "object" };
      const tool = makeTextExtractTool(() => mockContext);
      await tool.execute({ text: "test", json_schema: schema });

      const body = JSON.parse((globalThis.fetch as any).mock.calls[0][1].body);
      expect(body.response_format.json_schema.strict).toBe(true);
    });

    it("should use json_schema response format", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(
        mockChatResponse('{"a": 1}')
      );

      const schema = { type: "object" };
      const tool = makeTextExtractTool(() => mockContext);
      await tool.execute({ text: "test", json_schema: schema });

      const body = JSON.parse((globalThis.fetch as any).mock.calls[0][1].body);
      expect(body.response_format.type).toBe("json_schema");
    });

    it("should throw AuthError when API key is missing", async () => {
      setEnv({ OPENROUTER_API_KEY: "" });

      const tool = makeTextExtractTool(() => mockContext);

      await expect(
        tool.execute({ text: "test", json_schema: { type: "object" } })
      ).rejects.toThrow("OpenRouter API key not configured");
    });

    it("should classify HTTP errors from API", async () => {
      globalThis.fetch = vi.fn().mockResolvedValue(
        mockErrorResponse(401, "Unauthorized")
      );

      const tool = makeTextExtractTool(() => mockContext);

      await expect(
        tool.execute({ text: "test", json_schema: { type: "object" } })
      ).rejects.toThrow();
    });

    it("should be a read-only tool", () => {
      const tool = makeTextExtractTool(() => mockContext);
      expect(tool.isReadOnly?.({} as any)).toBe(true);
    });
  });
});

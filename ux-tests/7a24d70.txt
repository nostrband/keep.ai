# UX Test Report: Commit 7a24d70
# "Implement per-device notification tracking"

## Test Date: 2026-01-20
## Commit: 7a24d70cd454cb9e023de0b6f99e0bfcc3136242

## Summary
This commit implements per-device notification tracking to fix a multi-device issue where notifications would only appear on one device. Previously, a global `read_at` timestamp on the `chats` table meant that if Device A showed a notification, Device B would never receive it.

## Testing Methodology
Due to authentication requirements (OpenRouter API key needed) and the inherent multi-device nature of this feature, comprehensive UX testing requires:
1. Multiple devices or browser profiles
2. A valid API key to generate assistant messages
3. Browser notification permissions granted

This report is based on code review and analysis of the implementation.

## Feature Description

### What Changed for Users
**Before:**
- When Device A shows a notification for a message, Device B would never get that notification
- Single `read_at` timestamp was global across all devices

**After:**
- Each device maintains its own notification history
- Device A receiving a notification does NOT prevent Device B from also receiving it
- Users with multiple devices should now see notifications on each device independently

## UX Testing Checklist

### Scenarios That Need Multi-Device Testing

1. **Basic Multi-Device Notification Test**
   - [ ] Set up two devices (or browser profiles) logged into same account
   - [ ] Trigger an assistant message (create a chat, ask a question)
   - [ ] Minimize/hide Device A's browser tab
   - [ ] Verify Device A receives browser notification
   - [ ] Minimize/hide Device B's browser tab
   - [ ] Verify Device B ALSO receives browser notification for same message
   - **Expected:** Both devices receive notifications independently

2. **Sequential Device Notification Test**
   - [ ] Device A receives notification for Message 1
   - [ ] Later, Device B comes online
   - [ ] Verify Device B receives notification for Message 1 (even though Device A already got it)
   - **Expected:** Device B catches up on missed notifications

3. **Notification Sound Test**
   - [ ] Verify notification sound plays on each device
   - [ ] Verify 5-second delay between consecutive notifications is maintained
   - **Expected:** Sound plays once per notification, with proper spacing

4. **Desktop Notifications Setting**
   - [ ] Disable desktop notifications in app settings
   - [ ] Verify no notifications appear
   - [ ] Enable desktop notifications
   - [ ] Verify notifications resume
   - **Expected:** Setting respected per-device

### Single-Device Tests (Can Test Without Multi-Device Setup)

5. **Basic Notification Flow**
   - [ ] Open app in background tab
   - [ ] Trigger assistant message
   - [ ] Verify browser notification appears
   - [ ] Click notification
   - [ ] Verify no repeated notifications for same message
   - **Expected:** Notification appears once and is tracked

6. **Notification Timing**
   - [ ] Generate multiple assistant messages in quick succession
   - [ ] Verify 5-second spacing between notifications
   - **Expected:** Notifications are spaced 5 seconds apart

## Code Analysis Findings

### CONFIRMED WORKING: Per-Device Tracking Mechanism

The implementation correctly:
1. Uses cr-sqlite's `crsql_site_id()` as unique device identifier (line 114-125 in api.ts)
2. Creates local `chat_notifications` table that is NOT synced (v23.ts migration)
3. Tracks notification timestamps per (chat_id, device_id) combination
4. Queries for messages newer than last notification time for this specific device

```sql
-- Query finds messages not yet notified on THIS device
SELECT m.*
FROM messages AS m
LEFT JOIN chat_notifications AS cn ON cn.chat_id = m.thread_id AND cn.device_id = ?
WHERE (cn.notified_at IS NULL OR m.created_at > cn.notified_at) AND m.role = 'assistant'
```

### POTENTIAL ISSUE 1: Orphaned Records on Chat Deletion
**Severity: Low (Data Hygiene)**
**Not User-Facing**

When a chat is deleted via `deleteChat()`, the corresponding rows in `chat_notifications` are NOT cleaned up. This creates orphaned records that accumulate over time.

**Impact:**
- Database bloat over time
- No user-visible effect
- Should be fixed for code hygiene

**Recommendation:**
Add cleanup in `deleteChat()`:
```sql
DELETE FROM chat_notifications WHERE chat_id = ?
```

### POTENTIAL ISSUE 2: Ineffective notifyTablesChanged Call
**Severity: Very Low (Dead Code)**
**Not User-Facing**

The call `notifyTablesChanged(["chat_notifications"], true, api)` at line 47 is effectively a no-op because no React Query hooks subscribe to the "chat_notifications" table.

**Impact:**
- None functionally
- Dead code that could be removed

### POTENTIAL ISSUE 3: Missing thread_id Null Check
**Severity: Low (Defensive Coding)**
**Could Cause Crash**

At line 43-46 in MessageNotifications.ts:
```typescript
await api.chatStore.markChatNotifiedOnDevice(
  message.metadata!.threadId!,  // Non-null assertion
  this.deviceId
);
```

Uses non-null assertion (`!`) for `metadata` and `threadId`. If either is null/undefined, this will crash.

**Mitigation:**
The messages come from `getNewAssistantMessagesForDevice()` which filters by `thread_id`, so in practice these should always exist. However, defensive coding would add a check:
```typescript
if (message.metadata?.threadId) {
  await api.chatStore.markChatNotifiedOnDevice(
    message.metadata.threadId,
    this.deviceId
  );
}
```

## UX Behavior Verification

### Correct Behaviors Observed in Code

1. **Tab Visibility Check** - Notifications only show when tab is NOT visible
   ```typescript
   if (globalThis.document?.visibilityState !== "visible") {
   ```

2. **Role Check** - Only assistant messages trigger notifications
   ```typescript
   if (message.role !== "user") {
   ```

3. **Desktop Settings Check** - Respects user's notification preference
   ```typescript
   const notificationsEnabled = await this.checkDesktopNotificationsEnabled();
   if (!notificationsEnabled) return;
   ```

4. **Mutex Protection** - Prevents concurrent notification processing
   ```typescript
   if (this.isRunning) return;
   this.isRunning = true;
   ```

5. **5-Second Spacing** - Prevents notification spam
   ```typescript
   await this.sleep(5000);
   ```

## Conclusion

**VERDICT: FEATURE WORKS AS DESIGNED - MINOR CODE HYGIENE ISSUES**

The per-device notification tracking feature is correctly implemented:
- Each device gets its own notification history using cr-sqlite site_id
- The `chat_notifications` table is intentionally NOT synced (local-only)
- Messages are correctly filtered by device-specific notification timestamps
- All existing notification behaviors (sound, visibility check, role check) are preserved

**Known Issues (Non-Blocking):**
1. Orphaned records not cleaned up on chat deletion (data hygiene)
2. Ineffective notifyTablesChanged call (dead code)
3. Non-null assertions could crash on malformed data (defensive coding)

None of these issues affect the core UX of receiving notifications on multiple devices. The feature should work as intended for multi-device users.

## Files Changed
- apps/web/src/lib/MessageNotifications.ts - Uses per-device tracking
- packages/db/src/api.ts - Added getDeviceId() and getNewAssistantMessagesForDevice()
- packages/db/src/chat-store.ts - Added markChatNotifiedOnDevice() and getChatNotifiedAt()
- packages/db/src/database.ts - Registered migration v23
- packages/db/src/migrations/v23.ts - New chat_notifications table
- IMPLEMENTATION_PLAN.md - Documentation update

================================================================================
ISSUE REVIEW
================================================================================
- Issue #1 (Orphaned Records on Chat Deletion) - skipped
- Issue #2 (Ineffective notifyTablesChanged Call) - skipped
- Issue #3 (Missing thread_id Null Check) - skipped
